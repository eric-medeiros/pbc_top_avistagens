---
title: "TOP AVISTAGENS - INDIV√çDUOS"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    theme: yeti
---

```{r setup, include=FALSE}
library(here)
library(flexdashboard)
library(leaflet)
library(sf)
library(raster)
library(htmltools)
library(dplyr)
library(stringr)


pasta_output <- here("02_outputs")

# Listar todos os indiv√≠duos (pastas)
individuos <- list.files(pasta_output, full.names = FALSE, recursive = FALSE) %>% str_remove_all("kernel_|pontos_|p50_|p95_|.gpkg|.tif") %>% unique()

# Fun√ß√£o para carregar dados de um indiv√≠duo
carregar_individuo <- function(ind) {
  caminho_pontos <- here(pasta_output, paste0("pontos_", ind, ".gpkg"))
  caminho_kernel <- here(pasta_output, paste0("kernel_", ind, ".tif"))
  caminho_p50 <- here(pasta_output, paste0("p50_", ind, ".gpkg"))
  caminho_p95 <- here(pasta_output, paste0("p95_", ind, ".gpkg"))
  
  # Carregar dados
  pontos <- tryCatch(st_read(caminho_pontos, quiet = TRUE), error = function(e) NULL)
  kernel <- tryCatch(raster(caminho_kernel), error = function(e) NULL)
  p50 <- tryCatch(st_read(caminho_p50, quiet = TRUE), error = function(e) NULL)
  p95 <- tryCatch(st_read(caminho_p95, quiet = TRUE), error = function(e) NULL)
  
  # Transformar para WGS84 (4326) para o Leaflet
  if (!is.null(pontos)) pontos <- st_transform(pontos, 4326)
  if (!is.null(kernel)) kernel <- projectRaster(kernel, crs = crs("+init=epsg:4326"))
  if (!is.null(p50)) p50 <- st_transform(p50, 4326)
  if (!is.null(p95)) p95 <- st_transform(p95, 4326)
  
  list(
    pontos = pontos,
    kernel = kernel,
    p50 = p50,
    p95 = p95
  )
}

# Carregar todos os indiv√≠duos
dados_individuos <- list()
for (ind in individuos) {
  dados_individuos[[ind]] <- carregar_individuo(ind)
}

# Configura√ß√µes de cores
cores <- list(
  pontos = "yellow", kernel = "red", p50 = "blue", p95 = "green"
)
opacidade <- 0.4
```

```{r}
# Criar mapa base vazio
mapa_base <- leaflet() %>%
  addProviderTiles("CartoDB.Positron", group = "Light") %>%
  addProviderTiles("Esri.WorldImagery", group = "Sat√©lite") %>%
  addScaleBar(position = "bottomleft")

# Configura√ß√µes de cores - cores distintas para cada indiv√≠duo
cores_individuos <- list(
  "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FECA57", "#FF9FF3",
  "#54A0FF", "#5F27CD", "#00D2D3", "#FF9F43", "#10AC84", "#EE5A24",
  "#0984E3", "#A29BFE", "#FD79A8", "#E17055", "#00B894", "#E84393",
  "#6C5CE7", "#FDCB6E", "#00CEC9", "#FF7675", "#74B9FF", "#55EFC4",
  "#F368E0", "#1DD1A1"
)

# Atribuir cores aos indiv√≠duos
nomes_cores <- list()
for (i in seq_along(individuos)) {
  nomes_cores[[individuos[i]]] <- cores_individuos[[i]]
}

# Adicionar cada indiv√≠duo ao mapa
for (i in seq_along(individuos)) {
  ind <- individuos[i]
  cor_ind <- nomes_cores[[ind]]
  dados <- dados_individuos[[ind]]
  
  if (!is.null(dados$kernel)) {
    pal <- colorNumeric(
      palette = c("blue", "cyan", "yellow", "red"),  # gradiente estilo temperatura
      domain = values(dados$kernel),
      na.color = "transparent"
    )
    mapa_base <- mapa_base %>%
      addRasterImage(
        dados$kernel,
        colors = pal,
        opacity = opacidade,  # usa o valor global que voc√™ j√° definiu
        group = paste(ind, "- Kernel")
      )
  }
  
  if (!is.null(dados$p50)) {
    mapa_base <- mapa_base %>%
      addPolygons(
        data = dados$p50,
        color = "black",           # cor da linha
        fillColor = cor_ind,       # sem preenchimento
        fillOpacity = 0.05,        # totalmente transparente
        weight = 2,                # espessura da linha
        dashArray = "5,5",         # linha tracejada
        group = paste(ind, "- P50"),
        popup = paste(ind, "- Percentil 50")
      )
  }
  
  if (!is.null(dados$p95)) {
    mapa_base <- mapa_base %>%
      addPolygons(
        data = dados$p95,
        color = "black",          # contorno preto
        fillColor = cor_ind,      # leve preenchimento
        fillOpacity = 0.05,       # transparente
        weight = 1,
        dashArray = "1,5",        # linha pontilhada
        group = paste(ind, "- P95"),
        popup = paste(ind, "- Percentil 95")
      )
  }
  
  if (!is.null(dados$pontos)) {
    mapa_base <- mapa_base %>%
      addCircleMarkers(data = dados$pontos,
                       color = cor_ind, fillColor = cor_ind,
                       fillOpacity = 0.8, radius = 4, weight = 2,
                       group = paste(ind, "- Pontos"),
                       popup = ~paste0(
                         "<strong>Indiv√≠duo: ", ind, "</strong><br>",
                         "Data: ", data, "<br>",
                         "Grupo: ", grupo, "<br>",
                         "Tamanho grupo: ", ifelse(is.na(tam_grupo), "NA", tam_grupo), "<br>",
                         "Adultos: ", n_adultos, " | Juv: ", n_juvenis, " | Inf: ", n_infantes, "<br>",
                         ifelse(!is.na(Obs_grupo) & Obs_grupo != "", paste0("Obs: ", Obs_grupo), "")
                       ))
  }
}

# Atualizar controle de layers com todos os grupos
grupos_overlay <- c()
for (ind in individuos) {
  grupos_overlay <- c(grupos_overlay, 
                      paste(ind, "- Pontos"),
                      paste(ind, "- Kernel"), 
                      paste(ind, "- P50"),
                      paste(ind, "- P95"))
}

mapa_base <- mapa_base %>%
  addLayersControl(
    baseGroups = c("Light", "Sat√©lite"),
    overlayGroups = grupos_overlay,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup(grupos_overlay)  # Come√ßar com todas ocultas
```

# Mapa

```{r}
mapa_base
```


# Informa√ß√µes do Mapa
column
-------------

### Legenda por Tipo
- üü° Pontos: Locais de avistagem
- üî¥ Kernel: Densidade de uso
- üîµ P50: √Årea central (50%)
- üü¢ P95: √Årea de uso total (95%)

column
-------------

### Como Usar
1. Selecione um indiv√≠duo no menu acima
2. Use o controle ‚ò∞ para ligar/desligar camadas
3. Comece com "Todos" para ver overview
4. Selecione individual para focar em um

column
-------------

### Infos
- **Total de indiv√≠duos:** `r length(individuos)`
- **Arquivos por indiv√≠duo:**
- Pontos de avistagem (.gpkg)
- Kernel de densidade (.tif)
- Pol√≠gono P50 (.gpkg)
- Pol√≠gono P95 (.gpkg)
- **Sobre a an√°lise:**
- kernel density para padr√µes de uso de espa√ßo de cada indiv√≠duo
- Tipo de suaviza√ß√£o: Normal (gaussiana)
- Par√¢metro sigma da suaviza√ß√£o: 500m